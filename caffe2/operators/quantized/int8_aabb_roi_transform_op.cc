#include "caffe2/operators/quantized/int8_aabb_roi_transform_op.h"

namespace caffe2 {
namespace {

REGISTER_CPU_OPERATOR(Int8AABBRoITransform, Int8AABBRoITransformOp<CPUContext>);

OPERATOR_SCHEMA(Int8AABBRoITransform)
    .NumInputs(4)
    .NumOutputs(1)
    .SetDoc(R"DOC(
Transform proposal bounding boxes to target bounding box using bounding box
    regression deltas.
)DOC")
    .Input(
        0,
        "batch_splits",
        "Tensor of shape (num_images) with each element denoting the number "
        "of RoIs belonging to the corresponding image in batch")
    .Input(
        1,
        "boxes",
        "Axis-aligned bounding boxes in pixel coordinates, "
        "Size (num_rois, 4), format [x1, y1, x2, y2]. "
        "Proposals are grouped sequentially and in incremental order of image"
        " index.")
    .Input(
        2,
        "deltas",
        "Scale-invariant bounding box translations and scales, "
        "size (num_rois, num_classes * 4), "
        "format [dx, dy, dw, dh].")
    .Input(
        3,
        "image_info",
        "Image dimensions, size (num_images, 2), "
        "format [img_height, img_width].")
    .Output(
        0,
        "boxes",
        "Transformed axis-aligned bounding boxes in pixel coordinates, "
        "Size (num_proposals, num_classes * 4), "
        "format [x1, y1, x2, y2].");

SHOULD_NOT_DO_GRADIENT(Int8AABBRoITransform);
} // namespace

template <>
bool Int8AABBRoITransformOp<CPUContext>::RunOnDevice() {
  const Tensor& batch_splits_in = Input(0);
  const Tensor& input_boxes_tensor = Input(1);
  const int8::Int8TensorCPU& input_deltas_tensor =
      Inputs()[2]->template Get<int8::Int8TensorCPU>();
  const Tensor& image_info_tensor = Input(3);

  const int num_rois = input_boxes_tensor.dim32(0);
  CAFFE_ENFORCE_EQ(input_boxes_tensor.dim(), 2);
  CAFFE_ENFORCE_EQ(input_boxes_tensor.dim32(1), 4);

  CAFFE_ENFORCE_EQ(input_deltas_tensor.t.dim(), 2);
  CAFFE_ENFORCE_EQ(input_deltas_tensor.t.dim32(0), num_rois);
  CAFFE_ENFORCE_EQ(input_deltas_tensor.t.dim32(1) % 4, 0);
  const int num_classes = input_deltas_tensor.t.dim32(1) / 4;

  CAFFE_ENFORCE_EQ(image_info_tensor.dim(), 2);
  CAFFE_ENFORCE_EQ(image_info_tensor.dim32(1), 2);
  const int num_images = image_info_tensor.dim32(0);

  CAFFE_ENFORCE_EQ(batch_splits_in.dim(), 1);
  CAFFE_ENFORCE_EQ(batch_splits_in.dim32(0), num_images);

  const uint16_t* roi_data = input_boxes_tensor.data<uint16_t>();
  const uint8_t* deltas_ptr = input_deltas_tensor.t.data<uint8_t>();
  const int32_t deltas_zero_point = input_deltas_tensor.zero_point;
  const float deltas_scale = input_deltas_tensor.scale;
  const int32_t* batch_splits_data = batch_splits_in.data<int32_t>();

  CAFFE_ENFORCE_EQ(image_info_tensor.sizes(), (at::IntList{num_images, 2}));
  const uint16_t* image_info_ptr = image_info_tensor.data<uint16_t>();

  Tensor* output_boxes_tensor = Output(0, input_deltas_tensor.t.sizes(), at::dtype<uint16_t>());
  uint16_t* output_boxes_ptr = output_boxes_tensor->template mutable_data<uint16_t>();

  // We assume input_boxes_tensor and input_deltas_tensor over multiple batches are grouped
  // together in increasing order as generated by GenerateProposalsOp
  int roi_start = 0;
  for (int image_idx = 0; image_idx < num_images; image_idx++) {
    const int num_image_rois = batch_splits_data[image_idx];
    const float image_height = float(image_info_ptr[image_idx * 2 + 0]) * 0.125f;
    const float image_width = float(image_info_ptr[image_idx * 2 + 1]) * 0.125f;

    for (int roi_index = roi_start; roi_index < roi_start + num_image_rois;
         roi_index++) {
      const float roi_x1 = float(roi_data[roi_index * 4 + 0]) * 0.125f;
      const float roi_y1 = float(roi_data[roi_index * 4 + 1]) * 0.125f;
      const float roi_x2 = float(roi_data[roi_index * 4 + 2]) * 0.125f;
      const float roi_y2 = float(roi_data[roi_index * 4 + 3]) * 0.125f;
      for (int k = 0; k < num_classes; k++) {
        const float roi_width = roi_x2 - roi_x1;
        const float roi_height = roi_y2 - roi_y1;
        const float roi_ctr_x = 0.5f * (roi_x1 + roi_x2);
        const float roi_ctr_y = 0.5f * (roi_y1 + roi_y2);

        const float dx = (int32_t(deltas_ptr[roi_index * 4 * num_classes + 4 * k + 0]) - deltas_zero_point) * deltas_scale;
        const float dy = (int32_t(deltas_ptr[roi_index * 4 * num_classes + 4 * k + 1]) - deltas_zero_point) * deltas_scale;
        const float dw = (int32_t(deltas_ptr[roi_index * 4 * num_classes + 4 * k + 2]) - deltas_zero_point) * deltas_scale;
        const float dh = (int32_t(deltas_ptr[roi_index * 4 * num_classes + 4 * k + 3]) - deltas_zero_point) * deltas_scale;

        const float pred_ctr_x = dx * roi_width + roi_ctr_x;
        const float pred_ctr_y = dy * roi_height + roi_ctr_y;
        const float pred_width = expf(dw) * roi_width;
        const float pred_height = expf(dh) * roi_height;

        float pred_x1 = pred_ctr_x - 0.5f * pred_width;
        float pred_y1 = pred_ctr_y - 0.5f * pred_height;
        float pred_x2 = pred_ctr_x + 0.5f * pred_width;
        float pred_y2 = pred_ctr_y + 0.5f * pred_height;

        pred_x1 = std::min(std::max(pred_x1, 0.0f), image_width);
        pred_x2 = std::min(std::max(pred_x2, 0.0f), image_width);
        pred_y1 = std::min(std::max(pred_y1, 0.0f), image_height);
        pred_y2 = std::min(std::max(pred_y2, 0.0f), image_height);

        output_boxes_ptr[roi_index * 4 * num_classes + 4 * k + 0] =
            uint16_t(std::min(std::max(pred_x1 * 8.0f, 0.0f), 65535.0f));
        output_boxes_ptr[roi_index * 4 * num_classes + 4 * k + 1] =
            uint16_t(std::min(std::max(pred_y1 * 8.0f, 0.0f), 65535.0f));
        output_boxes_ptr[roi_index * 4 * num_classes + 4 * k + 2] =
            uint16_t(std::min(std::max(pred_x2 * 8.0f, 0.0f), 65535.0f));
        output_boxes_ptr[roi_index * 4 * num_classes + 4 * k + 3] =
            uint16_t(std::min(std::max(pred_y2 * 8.0f, 0.0f), 65535.0f));
      }
    }
    roi_start += num_rois;
  }

  return true;
}

} // namespace caffe2
