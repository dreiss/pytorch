#include "caffe2/operators/aabb_roi_transform_op.h"

namespace caffe2 {
namespace {

REGISTER_CPU_OPERATOR(AABBRoITransform, AABBRoITransformOp<CPUContext>);

// Input: box, delta Output: box
OPERATOR_SCHEMA(AABBRoITransform)
    .NumInputs(4)
    .NumOutputs(1)
    .SetDoc(R"DOC(
Transform proposal bounding boxes to target bounding box using bounding box
    regression deltas.
)DOC")
    .Input(
        0,
        "batch_splits",
        "Tensor of shape (num_images) with each element denoting the number "
        "of RoIs belonging to the corresponding image in batch")
    .Input(
        1,
        "boxes",
        "Axis-aligned bounding boxes in pixel coordinates, "
        "Size (num_rois, 4), format [x1, y1, x2, y2]. "
        "Proposals are grouped sequentially and in incremental order of image"
        " index.")
    .Input(
        2,
        "deltas",
        "Scale-invariant bounding box translations and scales, "
        "size (num_rois, num_classes * 4), "
        "format [dx, dy, dw, dh].")
    .Input(
        3,
        "image_info",
        "Image dimensions, size (num_images, 2), "
        "format [img_height, img_width]")
    .Output(
        0,
        "boxes",
        "Transformed axis-aligned bounding boxes in pixel coordinates, "
        "Size (num_proposals, num_classes * 4), "
        "format [x1, y1, x2, y2].");

SHOULD_NOT_DO_GRADIENT(AABBRoITransform);
} // namespace

template <>
bool AABBRoITransformOp<CPUContext>::RunOnDevice() {
  const Tensor& batch_splits_in = Input(0);
  const Tensor& roi_in = Input(1);
  const Tensor& delta_in = Input(2);
  const Tensor& iminfo_in = Input(3);

  const int box_dim = 4;
  const int num_rois = roi_in.dim32(0);
  CAFFE_ENFORCE_EQ(roi_in.dim(), 2);
  CAFFE_ENFORCE_EQ(roi_in.dim32(1), box_dim);

  CAFFE_ENFORCE_EQ(delta_in.dim(), 2);
  CAFFE_ENFORCE_EQ(delta_in.dim32(0), num_rois);
  CAFFE_ENFORCE_EQ(delta_in.dim32(1) % box_dim, 0);
  const int num_classes = delta_in.dim32(1) / box_dim;

  CAFFE_ENFORCE_EQ(iminfo_in.dim(), 2);
  CAFFE_ENFORCE_EQ(iminfo_in.dim32(1), 2);
  const int num_images = iminfo_in.dim32(0);

  CAFFE_ENFORCE_EQ(batch_splits_in.dim(), 1);
  CAFFE_ENFORCE_EQ(batch_splits_in.dim32(0), num_images);

  const float* roi_data = roi_in.data<float>();
  const float* delta_data = delta_in.data<float>();
  const int32_t* batch_splits_data = batch_splits_in.data<int32_t>();

  CAFFE_ENFORCE_EQ(iminfo_in.sizes(), (at::IntList{num_images, 2}));
  const float* iminfo_data = iminfo_in.data<float>();

  Tensor* box_out = Output(0, delta_in.sizes(), at::dtype<float>());
  float* box_out_data = box_out->template mutable_data<float>();

  // We assume roi_in and delta_in over multiple batches are grouped
  // together in increasing order as generated by GenerateProposalsOp
  int roi_start = 0;
  for (int image_idx = 0; image_idx < num_images; image_idx++) {
    const int num_image_rois = batch_splits_data[image_idx];
    const float image_height = iminfo_data[image_idx * 2 + 0];
    const float image_width = iminfo_data[image_idx * 2 + 1];

    for (int roi_index = roi_start; roi_index < roi_start + num_image_rois;
         roi_index++) {
      const float roi_x1 = roi_data[roi_index * 4 + 0];
      const float roi_y1 = roi_data[roi_index * 4 + 1];
      const float roi_x2 = roi_data[roi_index * 4 + 2];
      const float roi_y2 = roi_data[roi_index * 4 + 3];
      for (int k = 0; k < num_classes; k++) {
        const float roi_width = roi_x2 - roi_x1;
        const float roi_height = roi_y2 - roi_y1;
        const float roi_ctr_x = 0.5f * (roi_x1 + roi_x2);
        const float roi_ctr_y = 0.5f * (roi_y1 + roi_y2);

        const float dx = delta_data[roi_index * 4 * num_classes + 4 * k + 0];
        const float dy = delta_data[roi_index * 4 * num_classes + 4 * k + 1];
        const float dw = delta_data[roi_index * 4 * num_classes + 4 * k + 2];
        const float dh = delta_data[roi_index * 4 * num_classes + 4 * k + 3];

        const float pred_ctr_x = dx * roi_width + roi_ctr_x;
        const float pred_ctr_y = dy * roi_height + roi_ctr_y;
        const float pred_width = expf(dw) * roi_width;
        const float pred_height = expf(dh) * roi_height;

        float pred_x1 = pred_ctr_x - 0.5f * pred_width;
        float pred_y1 = pred_ctr_y - 0.5f * pred_height;
        float pred_x2 = pred_ctr_x + 0.5f * pred_width;
        float pred_y2 = pred_ctr_y + 0.5f * pred_height;

        pred_x1 = std::min(std::max(pred_x1, 0.0f), image_width);
        pred_x2 = std::min(std::max(pred_x2, 0.0f), image_width);
        pred_y1 = std::min(std::max(pred_y1, 0.0f), image_height);
        pred_y2 = std::min(std::max(pred_y2, 0.0f), image_height);

        box_out_data[roi_index * 4 * num_classes + 4 * k + 0] = pred_x1;
        box_out_data[roi_index * 4 * num_classes + 4 * k + 1] = pred_y1;
        box_out_data[roi_index * 4 * num_classes + 4 * k + 2] = pred_x2;
        box_out_data[roi_index * 4 * num_classes + 4 * k + 3] = pred_y2;
      }
    }
    roi_start += num_rois;
  }

  return true;
}

} // namespace caffe2
